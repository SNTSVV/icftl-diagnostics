# Generated from scsl.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,38,332,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,1,0,1,0,1,
        1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,5,3,5,92,8,5,1,6,1,6,1,7,
        1,7,1,8,1,8,1,9,1,9,1,10,1,10,1,11,1,11,1,12,1,12,1,13,1,13,1,13,
        1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,
        1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,133,8,15,1,15,
        1,15,1,15,1,15,1,15,1,15,1,15,1,15,5,15,143,8,15,10,15,12,15,146,
        9,15,1,16,1,16,3,16,150,8,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
        3,17,159,8,17,1,18,1,18,1,18,1,18,1,18,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,3,19,173,8,19,1,20,1,20,1,20,1,20,1,20,1,21,1,21,1,21,
        3,21,183,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,23,1,23,1,23,3,23,
        194,8,23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
        1,24,1,24,1,24,1,24,1,24,1,24,3,24,213,8,24,1,24,1,24,1,24,5,24,
        218,8,24,10,24,12,24,221,9,24,1,25,1,25,1,25,1,25,1,25,1,25,3,25,
        229,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
        1,26,3,26,243,8,26,1,27,1,27,1,27,1,27,1,27,1,28,1,28,1,29,1,29,
        1,30,1,30,1,30,3,30,257,8,30,1,31,1,31,1,31,1,31,1,32,1,32,1,32,
        1,32,1,33,1,33,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,286,8,34,1,35,1,35,1,36,
        1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,
        1,36,3,36,305,8,36,1,37,1,37,1,37,1,37,1,37,1,37,3,37,313,8,37,1,
        38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
        38,1,38,3,38,330,8,38,1,38,0,2,30,48,39,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,0,3,1,0,18,19,1,0,1,3,1,0,16,17,330,0,78,1,
        0,0,0,2,80,1,0,0,0,4,82,1,0,0,0,6,84,1,0,0,0,8,86,1,0,0,0,10,91,
        1,0,0,0,12,93,1,0,0,0,14,95,1,0,0,0,16,97,1,0,0,0,18,99,1,0,0,0,
        20,101,1,0,0,0,22,103,1,0,0,0,24,105,1,0,0,0,26,107,1,0,0,0,28,112,
        1,0,0,0,30,132,1,0,0,0,32,149,1,0,0,0,34,158,1,0,0,0,36,160,1,0,
        0,0,38,172,1,0,0,0,40,174,1,0,0,0,42,182,1,0,0,0,44,184,1,0,0,0,
        46,193,1,0,0,0,48,212,1,0,0,0,50,228,1,0,0,0,52,242,1,0,0,0,54,244,
        1,0,0,0,56,249,1,0,0,0,58,251,1,0,0,0,60,256,1,0,0,0,62,258,1,0,
        0,0,64,262,1,0,0,0,66,266,1,0,0,0,68,285,1,0,0,0,70,287,1,0,0,0,
        72,304,1,0,0,0,74,312,1,0,0,0,76,329,1,0,0,0,78,79,5,5,0,0,79,1,
        1,0,0,0,80,81,7,0,0,0,81,3,1,0,0,0,82,83,5,29,0,0,83,5,1,0,0,0,84,
        85,5,30,0,0,85,7,1,0,0,0,86,87,5,31,0,0,87,9,1,0,0,0,88,92,3,0,0,
        0,89,92,3,14,7,0,90,92,5,38,0,0,91,88,1,0,0,0,91,89,1,0,0,0,91,90,
        1,0,0,0,92,11,1,0,0,0,93,94,5,38,0,0,94,13,1,0,0,0,95,96,5,4,0,0,
        96,15,1,0,0,0,97,98,5,38,0,0,98,17,1,0,0,0,99,100,5,38,0,0,100,19,
        1,0,0,0,101,102,5,21,0,0,102,21,1,0,0,0,103,104,5,22,0,0,104,23,
        1,0,0,0,105,106,3,26,13,0,106,25,1,0,0,0,107,108,3,28,14,0,108,109,
        5,11,0,0,109,110,3,30,15,0,110,111,5,12,0,0,111,27,1,0,0,0,112,113,
        3,2,1,0,113,114,3,12,6,0,114,115,5,20,0,0,115,116,3,32,16,0,116,
        29,1,0,0,0,117,118,6,15,-1,0,118,133,3,26,13,0,119,120,3,8,4,0,120,
        121,5,9,0,0,121,122,3,30,15,0,122,123,5,10,0,0,123,133,1,0,0,0,124,
        133,5,32,0,0,125,133,5,33,0,0,126,133,3,60,30,0,127,133,3,68,34,
        0,128,129,5,9,0,0,129,130,3,30,15,0,130,131,5,10,0,0,131,133,1,0,
        0,0,132,117,1,0,0,0,132,119,1,0,0,0,132,124,1,0,0,0,132,125,1,0,
        0,0,132,126,1,0,0,0,132,127,1,0,0,0,132,128,1,0,0,0,133,144,1,0,
        0,0,134,135,10,8,0,0,135,136,3,4,2,0,136,137,3,30,15,9,137,143,1,
        0,0,0,138,139,10,7,0,0,139,140,3,6,3,0,140,141,3,30,15,8,141,143,
        1,0,0,0,142,134,1,0,0,0,142,138,1,0,0,0,143,146,1,0,0,0,144,142,
        1,0,0,0,144,145,1,0,0,0,145,31,1,0,0,0,146,144,1,0,0,0,147,150,3,
        34,17,0,148,150,3,44,22,0,149,147,1,0,0,0,149,148,1,0,0,0,150,33,
        1,0,0,0,151,152,3,36,18,0,152,153,3,40,20,0,153,159,1,0,0,0,154,
        155,3,36,18,0,155,156,3,40,20,0,156,157,3,42,21,0,157,159,1,0,0,
        0,158,151,1,0,0,0,158,154,1,0,0,0,159,35,1,0,0,0,160,161,3,18,9,
        0,161,162,5,9,0,0,162,163,3,38,19,0,163,164,5,10,0,0,164,37,1,0,
        0,0,165,173,3,14,7,0,166,167,5,15,0,0,167,173,3,14,7,0,168,169,3,
        14,7,0,169,170,3,38,19,0,170,173,1,0,0,0,171,173,1,0,0,0,172,165,
        1,0,0,0,172,166,1,0,0,0,172,168,1,0,0,0,172,171,1,0,0,0,173,39,1,
        0,0,0,174,175,5,36,0,0,175,176,5,9,0,0,176,177,3,14,7,0,177,178,
        5,10,0,0,178,41,1,0,0,0,179,180,5,22,0,0,180,183,3,48,24,0,181,183,
        1,0,0,0,182,179,1,0,0,0,182,181,1,0,0,0,183,43,1,0,0,0,184,185,5,
        13,0,0,185,186,3,48,24,0,186,187,5,15,0,0,187,188,3,48,24,0,188,
        189,5,14,0,0,189,45,1,0,0,0,190,194,3,48,24,0,191,194,3,50,25,0,
        192,194,3,52,26,0,193,190,1,0,0,0,193,191,1,0,0,0,193,192,1,0,0,
        0,194,47,1,0,0,0,195,196,6,24,-1,0,196,213,3,12,6,0,197,213,3,0,
        0,0,198,199,5,9,0,0,199,200,5,27,0,0,200,201,3,52,26,0,201,202,5,
        10,0,0,202,213,1,0,0,0,203,204,5,9,0,0,204,205,5,27,0,0,205,206,
        3,50,25,0,206,207,5,10,0,0,207,213,1,0,0,0,208,209,5,9,0,0,209,210,
        3,48,24,0,210,211,5,10,0,0,211,213,1,0,0,0,212,195,1,0,0,0,212,197,
        1,0,0,0,212,198,1,0,0,0,212,203,1,0,0,0,212,208,1,0,0,0,213,219,
        1,0,0,0,214,215,10,2,0,0,215,216,5,16,0,0,216,218,3,0,0,0,217,214,
        1,0,0,0,218,221,1,0,0,0,219,217,1,0,0,0,219,220,1,0,0,0,220,49,1,
        0,0,0,221,219,1,0,0,0,222,229,3,12,6,0,223,229,3,54,27,0,224,225,
        5,9,0,0,225,226,3,50,25,0,226,227,5,10,0,0,227,229,1,0,0,0,228,222,
        1,0,0,0,228,223,1,0,0,0,228,224,1,0,0,0,229,51,1,0,0,0,230,243,3,
        12,6,0,231,243,3,54,27,0,232,233,3,20,10,0,233,234,3,50,25,0,234,
        243,1,0,0,0,235,236,3,22,11,0,236,237,3,50,25,0,237,243,1,0,0,0,
        238,239,5,9,0,0,239,240,3,52,26,0,240,241,5,10,0,0,241,243,1,0,0,
        0,242,230,1,0,0,0,242,231,1,0,0,0,242,232,1,0,0,0,242,235,1,0,0,
        0,242,238,1,0,0,0,243,53,1,0,0,0,244,245,5,23,0,0,245,246,3,46,23,
        0,246,247,5,20,0,0,247,248,3,32,16,0,248,55,1,0,0,0,249,250,7,1,
        0,0,250,57,1,0,0,0,251,252,7,2,0,0,252,59,1,0,0,0,253,257,3,62,31,
        0,254,257,3,64,32,0,255,257,3,66,33,0,256,253,1,0,0,0,256,254,1,
        0,0,0,256,255,1,0,0,0,257,61,1,0,0,0,258,259,3,72,36,0,259,260,3,
        56,28,0,260,261,3,0,0,0,261,63,1,0,0,0,262,263,3,74,37,0,263,264,
        3,56,28,0,264,265,3,0,0,0,265,65,1,0,0,0,266,267,3,76,38,0,267,268,
        3,56,28,0,268,269,3,10,5,0,269,67,1,0,0,0,270,271,3,76,38,0,271,
        272,3,56,28,0,272,273,3,76,38,0,273,286,1,0,0,0,274,275,3,72,36,
        0,275,276,3,56,28,0,276,277,3,72,36,0,277,286,1,0,0,0,278,279,3,
        70,35,0,279,280,3,52,26,0,280,281,5,37,0,0,281,282,3,52,26,0,282,
        283,3,56,28,0,283,284,3,0,0,0,284,286,1,0,0,0,285,270,1,0,0,0,285,
        274,1,0,0,0,285,278,1,0,0,0,286,69,1,0,0,0,287,288,5,28,0,0,288,
        71,1,0,0,0,289,290,5,25,0,0,290,291,3,16,8,0,291,292,5,34,0,0,292,
        293,3,48,24,0,293,305,1,0,0,0,294,295,5,9,0,0,295,296,3,72,36,0,
        296,297,5,10,0,0,297,298,3,58,29,0,298,299,3,0,0,0,299,305,1,0,0,
        0,300,301,5,9,0,0,301,302,3,72,36,0,302,303,5,10,0,0,303,305,1,0,
        0,0,304,289,1,0,0,0,304,294,1,0,0,0,304,300,1,0,0,0,305,73,1,0,0,
        0,306,307,5,26,0,0,307,313,3,50,25,0,308,309,5,9,0,0,309,310,3,74,
        37,0,310,311,5,10,0,0,311,313,1,0,0,0,312,306,1,0,0,0,312,308,1,
        0,0,0,313,75,1,0,0,0,314,315,5,24,0,0,315,316,3,14,7,0,316,317,5,
        35,0,0,317,318,3,52,26,0,318,330,1,0,0,0,319,320,5,9,0,0,320,321,
        3,76,38,0,321,322,5,10,0,0,322,323,3,58,29,0,323,324,3,0,0,0,324,
        330,1,0,0,0,325,326,5,9,0,0,326,327,3,76,38,0,327,328,5,10,0,0,328,
        330,1,0,0,0,329,314,1,0,0,0,329,319,1,0,0,0,329,325,1,0,0,0,330,
        77,1,0,0,0,18,91,132,142,144,149,158,172,182,193,212,219,228,242,
        256,285,304,312,329
    ]

class scslParser ( Parser ):

    grammarFileName = "scsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'<'", "'>'", "'='", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'\\n'", "<INVALID>", "'('", "')'", "'{'", 
                     "'}'", "'['", "']'", "','", "'+'", "'-'", "'for every'", 
                     "'there is a'", "'satisfying'", "'before'", "'after'", 
                     "'next after'", "'value variable'", "'value signal'", 
                     "'duration'", "'timestamp'", "'time to'", "'or'", "'and'", 
                     "'not'", "'true'", "'false'", "'at time'", "'in'", 
                     "'.during'", "'from'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "STR", "REAL", "INT", "NEWLINE", "WS", "LB", "RB", 
                      "LP", "RP", "LSB", "RSB", "COMMA", "PLUS", "MINUS", 
                      "FORALL", "EXISTS", "SATISFYING", "BEFORE", "AFTER", 
                      "NEXTOPKWS", "VALUEKWS", "SIGNALVALUEKWS", "DURATION", 
                      "TIME", "TIMEBETWEEN", "OR", "AND", "NOT", "TRUE", 
                      "FALSE", "ATTIME", "IN", "DURING", "FROM", "ID" ]

    RULE_real_number = 0
    RULE_quant = 1
    RULE_disjunction = 2
    RULE_conjunction = 3
    RULE_negation = 4
    RULE_value = 5
    RULE_variable = 6
    RULE_string = 7
    RULE_signal_variable = 8
    RULE_predicate_name = 9
    RULE_beforeTr = 10
    RULE_afterTr = 11
    RULE_spec = 12
    RULE_quantifier_block = 13
    RULE_quant_section = 14
    RULE_inner = 15
    RULE_predicate = 16
    RULE_source_code_predicate = 17
    RULE_dsl_predicate = 18
    RULE_predicate_args = 19
    RULE_procedure_qualifier = 20
    RULE_after_qualifier = 21
    RULE_timestamp_predicate = 22
    RULE_expr = 23
    RULE_ts = 24
    RULE_tr = 25
    RULE_c = 26
    RULE_nextOp = 27
    RULE_cmp = 28
    RULE_arithmetic = 29
    RULE_phi_single = 30
    RULE_phi_ts = 31
    RULE_phi_tr = 32
    RULE_phi_c = 33
    RULE_phi_multiple = 34
    RULE_timeBetween = 35
    RULE_v_ts = 36
    RULE_v_tr = 37
    RULE_v_c = 38

    ruleNames =  [ "real_number", "quant", "disjunction", "conjunction", 
                   "negation", "value", "variable", "string", "signal_variable", 
                   "predicate_name", "beforeTr", "afterTr", "spec", "quantifier_block", 
                   "quant_section", "inner", "predicate", "source_code_predicate", 
                   "dsl_predicate", "predicate_args", "procedure_qualifier", 
                   "after_qualifier", "timestamp_predicate", "expr", "ts", 
                   "tr", "c", "nextOp", "cmp", "arithmetic", "phi_single", 
                   "phi_ts", "phi_tr", "phi_c", "phi_multiple", "timeBetween", 
                   "v_ts", "v_tr", "v_c" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    STR=4
    REAL=5
    INT=6
    NEWLINE=7
    WS=8
    LB=9
    RB=10
    LP=11
    RP=12
    LSB=13
    RSB=14
    COMMA=15
    PLUS=16
    MINUS=17
    FORALL=18
    EXISTS=19
    SATISFYING=20
    BEFORE=21
    AFTER=22
    NEXTOPKWS=23
    VALUEKWS=24
    SIGNALVALUEKWS=25
    DURATION=26
    TIME=27
    TIMEBETWEEN=28
    OR=29
    AND=30
    NOT=31
    TRUE=32
    FALSE=33
    ATTIME=34
    IN=35
    DURING=36
    FROM=37
    ID=38

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Real_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL(self):
            return self.getToken(scslParser.REAL, 0)

        def getRuleIndex(self):
            return scslParser.RULE_real_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReal_number" ):
                return visitor.visitReal_number(self)
            else:
                return visitor.visitChildren(self)




    def real_number(self):

        localctx = scslParser.Real_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_real_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(scslParser.REAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORALL(self):
            return self.getToken(scslParser.FORALL, 0)

        def EXISTS(self):
            return self.getToken(scslParser.EXISTS, 0)

        def getRuleIndex(self):
            return scslParser.RULE_quant

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuant" ):
                return visitor.visitQuant(self)
            else:
                return visitor.visitChildren(self)




    def quant(self):

        localctx = scslParser.QuantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_quant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            _la = self._input.LA(1)
            if not(_la==18 or _la==19):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(scslParser.OR, 0)

        def getRuleIndex(self):
            return scslParser.RULE_disjunction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisjunction" ):
                return visitor.visitDisjunction(self)
            else:
                return visitor.visitChildren(self)




    def disjunction(self):

        localctx = scslParser.DisjunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_disjunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.match(scslParser.OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConjunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(scslParser.AND, 0)

        def getRuleIndex(self):
            return scslParser.RULE_conjunction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConjunction" ):
                return visitor.visitConjunction(self)
            else:
                return visitor.visitChildren(self)




    def conjunction(self):

        localctx = scslParser.ConjunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_conjunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(scslParser.AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NegationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(scslParser.NOT, 0)

        def getRuleIndex(self):
            return scslParser.RULE_negation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNegation" ):
                return visitor.visitNegation(self)
            else:
                return visitor.visitChildren(self)




    def negation(self):

        localctx = scslParser.NegationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_negation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(scslParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def string(self):
            return self.getTypedRuleContext(scslParser.StringContext,0)


        def ID(self):
            return self.getToken(scslParser.ID, 0)

        def getRuleIndex(self):
            return scslParser.RULE_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = scslParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_value)
        try:
            self.state = 91
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 88
                self.real_number()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.string()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 3)
                self.state = 90
                self.match(scslParser.ID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(scslParser.ID, 0)

        def getRuleIndex(self):
            return scslParser.RULE_variable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = scslParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(scslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STR(self):
            return self.getToken(scslParser.STR, 0)

        def getRuleIndex(self):
            return scslParser.RULE_string

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString" ):
                return visitor.visitString(self)
            else:
                return visitor.visitChildren(self)




    def string(self):

        localctx = scslParser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(scslParser.STR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signal_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(scslParser.ID, 0)

        def getRuleIndex(self):
            return scslParser.RULE_signal_variable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignal_variable" ):
                return visitor.visitSignal_variable(self)
            else:
                return visitor.visitChildren(self)




    def signal_variable(self):

        localctx = scslParser.Signal_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_signal_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.match(scslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Predicate_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(scslParser.ID, 0)

        def getRuleIndex(self):
            return scslParser.RULE_predicate_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate_name" ):
                return visitor.visitPredicate_name(self)
            else:
                return visitor.visitChildren(self)




    def predicate_name(self):

        localctx = scslParser.Predicate_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_predicate_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(scslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeforeTrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEFORE(self):
            return self.getToken(scslParser.BEFORE, 0)

        def getRuleIndex(self):
            return scslParser.RULE_beforeTr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeforeTr" ):
                return visitor.visitBeforeTr(self)
            else:
                return visitor.visitChildren(self)




    def beforeTr(self):

        localctx = scslParser.BeforeTrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_beforeTr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(scslParser.BEFORE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AfterTrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFTER(self):
            return self.getToken(scslParser.AFTER, 0)

        def getRuleIndex(self):
            return scslParser.RULE_afterTr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfterTr" ):
                return visitor.visitAfterTr(self)
            else:
                return visitor.visitChildren(self)




    def afterTr(self):

        localctx = scslParser.AfterTrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_afterTr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(scslParser.AFTER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantifier_block(self):
            return self.getTypedRuleContext(scslParser.Quantifier_blockContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_spec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpec" ):
                return visitor.visitSpec(self)
            else:
                return visitor.visitChildren(self)




    def spec(self):

        localctx = scslParser.SpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.quantifier_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Quantifier_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quant_section(self):
            return self.getTypedRuleContext(scslParser.Quant_sectionContext,0)


        def LP(self):
            return self.getToken(scslParser.LP, 0)

        def inner(self):
            return self.getTypedRuleContext(scslParser.InnerContext,0)


        def RP(self):
            return self.getToken(scslParser.RP, 0)

        def getRuleIndex(self):
            return scslParser.RULE_quantifier_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantifier_block" ):
                return visitor.visitQuantifier_block(self)
            else:
                return visitor.visitChildren(self)




    def quantifier_block(self):

        localctx = scslParser.Quantifier_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_quantifier_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.quant_section()
            self.state = 108
            self.match(scslParser.LP)
            self.state = 109
            self.inner(0)
            self.state = 110
            self.match(scslParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Quant_sectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quant(self):
            return self.getTypedRuleContext(scslParser.QuantContext,0)


        def variable(self):
            return self.getTypedRuleContext(scslParser.VariableContext,0)


        def SATISFYING(self):
            return self.getToken(scslParser.SATISFYING, 0)

        def predicate(self):
            return self.getTypedRuleContext(scslParser.PredicateContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_quant_section

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuant_section" ):
                return visitor.visitQuant_section(self)
            else:
                return visitor.visitChildren(self)




    def quant_section(self):

        localctx = scslParser.Quant_sectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_quant_section)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.quant()
            self.state = 113
            self.variable()
            self.state = 114
            self.match(scslParser.SATISFYING)
            self.state = 115
            self.predicate()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantifier_block(self):
            return self.getTypedRuleContext(scslParser.Quantifier_blockContext,0)


        def negation(self):
            return self.getTypedRuleContext(scslParser.NegationContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def inner(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(scslParser.InnerContext)
            else:
                return self.getTypedRuleContext(scslParser.InnerContext,i)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def TRUE(self):
            return self.getToken(scslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(scslParser.FALSE, 0)

        def phi_single(self):
            return self.getTypedRuleContext(scslParser.Phi_singleContext,0)


        def phi_multiple(self):
            return self.getTypedRuleContext(scslParser.Phi_multipleContext,0)


        def disjunction(self):
            return self.getTypedRuleContext(scslParser.DisjunctionContext,0)


        def conjunction(self):
            return self.getTypedRuleContext(scslParser.ConjunctionContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_inner

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInner" ):
                return visitor.visitInner(self)
            else:
                return visitor.visitChildren(self)



    def inner(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = scslParser.InnerContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_inner, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 118
                self.quantifier_block()
                pass

            elif la_ == 2:
                self.state = 119
                self.negation()
                self.state = 120
                self.match(scslParser.LB)
                self.state = 121
                self.inner(0)
                self.state = 122
                self.match(scslParser.RB)
                pass

            elif la_ == 3:
                self.state = 124
                self.match(scslParser.TRUE)
                pass

            elif la_ == 4:
                self.state = 125
                self.match(scslParser.FALSE)
                pass

            elif la_ == 5:
                self.state = 126
                self.phi_single()
                pass

            elif la_ == 6:
                self.state = 127
                self.phi_multiple()
                pass

            elif la_ == 7:
                self.state = 128
                self.match(scslParser.LB)
                self.state = 129
                self.inner(0)
                self.state = 130
                self.match(scslParser.RB)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 144
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 142
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                    if la_ == 1:
                        localctx = scslParser.InnerContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_inner)
                        self.state = 134
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 135
                        self.disjunction()
                        self.state = 136
                        self.inner(9)
                        pass

                    elif la_ == 2:
                        localctx = scslParser.InnerContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_inner)
                        self.state = 138
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 139
                        self.conjunction()
                        self.state = 140
                        self.inner(8)
                        pass

             
                self.state = 146
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def source_code_predicate(self):
            return self.getTypedRuleContext(scslParser.Source_code_predicateContext,0)


        def timestamp_predicate(self):
            return self.getTypedRuleContext(scslParser.Timestamp_predicateContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_predicate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = scslParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_predicate)
        try:
            self.state = 149
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [38]:
                self.enterOuterAlt(localctx, 1)
                self.state = 147
                self.source_code_predicate()
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 148
                self.timestamp_predicate()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_code_predicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dsl_predicate(self):
            return self.getTypedRuleContext(scslParser.Dsl_predicateContext,0)


        def procedure_qualifier(self):
            return self.getTypedRuleContext(scslParser.Procedure_qualifierContext,0)


        def after_qualifier(self):
            return self.getTypedRuleContext(scslParser.After_qualifierContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_source_code_predicate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_code_predicate" ):
                return visitor.visitSource_code_predicate(self)
            else:
                return visitor.visitChildren(self)




    def source_code_predicate(self):

        localctx = scslParser.Source_code_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_source_code_predicate)
        try:
            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 151
                self.dsl_predicate()
                self.state = 152
                self.procedure_qualifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 154
                self.dsl_predicate()
                self.state = 155
                self.procedure_qualifier()
                self.state = 156
                self.after_qualifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dsl_predicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate_name(self):
            return self.getTypedRuleContext(scslParser.Predicate_nameContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def predicate_args(self):
            return self.getTypedRuleContext(scslParser.Predicate_argsContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_dsl_predicate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDsl_predicate" ):
                return visitor.visitDsl_predicate(self)
            else:
                return visitor.visitChildren(self)




    def dsl_predicate(self):

        localctx = scslParser.Dsl_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_dsl_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.predicate_name()
            self.state = 161
            self.match(scslParser.LB)
            self.state = 162
            self.predicate_args()
            self.state = 163
            self.match(scslParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Predicate_argsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self):
            return self.getTypedRuleContext(scslParser.StringContext,0)


        def COMMA(self):
            return self.getToken(scslParser.COMMA, 0)

        def predicate_args(self):
            return self.getTypedRuleContext(scslParser.Predicate_argsContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_predicate_args

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate_args" ):
                return visitor.visitPredicate_args(self)
            else:
                return visitor.visitChildren(self)




    def predicate_args(self):

        localctx = scslParser.Predicate_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_predicate_args)
        try:
            self.state = 172
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 165
                self.string()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 166
                self.match(scslParser.COMMA)
                self.state = 167
                self.string()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 168
                self.string()
                self.state = 169
                self.predicate_args()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Procedure_qualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DURING(self):
            return self.getToken(scslParser.DURING, 0)

        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def string(self):
            return self.getTypedRuleContext(scslParser.StringContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_procedure_qualifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedure_qualifier" ):
                return visitor.visitProcedure_qualifier(self)
            else:
                return visitor.visitChildren(self)




    def procedure_qualifier(self):

        localctx = scslParser.Procedure_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_procedure_qualifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(scslParser.DURING)
            self.state = 175
            self.match(scslParser.LB)
            self.state = 176
            self.string()
            self.state = 177
            self.match(scslParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class After_qualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFTER(self):
            return self.getToken(scslParser.AFTER, 0)

        def ts(self):
            return self.getTypedRuleContext(scslParser.TsContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_after_qualifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfter_qualifier" ):
                return visitor.visitAfter_qualifier(self)
            else:
                return visitor.visitChildren(self)




    def after_qualifier(self):

        localctx = scslParser.After_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_after_qualifier)
        try:
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 179
                self.match(scslParser.AFTER)
                self.state = 180
                self.ts(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timestamp_predicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSB(self):
            return self.getToken(scslParser.LSB, 0)

        def ts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(scslParser.TsContext)
            else:
                return self.getTypedRuleContext(scslParser.TsContext,i)


        def COMMA(self):
            return self.getToken(scslParser.COMMA, 0)

        def RSB(self):
            return self.getToken(scslParser.RSB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_timestamp_predicate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimestamp_predicate" ):
                return visitor.visitTimestamp_predicate(self)
            else:
                return visitor.visitChildren(self)




    def timestamp_predicate(self):

        localctx = scslParser.Timestamp_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_timestamp_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(scslParser.LSB)
            self.state = 185
            self.ts(0)
            self.state = 186
            self.match(scslParser.COMMA)
            self.state = 187
            self.ts(0)
            self.state = 188
            self.match(scslParser.RSB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ts(self):
            return self.getTypedRuleContext(scslParser.TsContext,0)


        def tr(self):
            return self.getTypedRuleContext(scslParser.TrContext,0)


        def c(self):
            return self.getTypedRuleContext(scslParser.CContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = scslParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_expr)
        try:
            self.state = 193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 190
                self.ts(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 191
                self.tr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 192
                self.c()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(scslParser.VariableContext,0)


        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def TIME(self):
            return self.getToken(scslParser.TIME, 0)

        def c(self):
            return self.getTypedRuleContext(scslParser.CContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def tr(self):
            return self.getTypedRuleContext(scslParser.TrContext,0)


        def ts(self):
            return self.getTypedRuleContext(scslParser.TsContext,0)


        def PLUS(self):
            return self.getToken(scslParser.PLUS, 0)

        def getRuleIndex(self):
            return scslParser.RULE_ts

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTs" ):
                return visitor.visitTs(self)
            else:
                return visitor.visitChildren(self)



    def ts(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = scslParser.TsContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 48
        self.enterRecursionRule(localctx, 48, self.RULE_ts, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 196
                self.variable()
                pass

            elif la_ == 2:
                self.state = 197
                self.real_number()
                pass

            elif la_ == 3:
                self.state = 198
                self.match(scslParser.LB)
                self.state = 199
                self.match(scslParser.TIME)
                self.state = 200
                self.c()
                self.state = 201
                self.match(scslParser.RB)
                pass

            elif la_ == 4:
                self.state = 203
                self.match(scslParser.LB)
                self.state = 204
                self.match(scslParser.TIME)
                self.state = 205
                self.tr()
                self.state = 206
                self.match(scslParser.RB)
                pass

            elif la_ == 5:
                self.state = 208
                self.match(scslParser.LB)
                self.state = 209
                self.ts(0)
                self.state = 210
                self.match(scslParser.RB)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 219
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = scslParser.TsContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_ts)
                    self.state = 214
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 215
                    self.match(scslParser.PLUS)
                    self.state = 216
                    self.real_number() 
                self.state = 221
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(scslParser.VariableContext,0)


        def nextOp(self):
            return self.getTypedRuleContext(scslParser.NextOpContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def tr(self):
            return self.getTypedRuleContext(scslParser.TrContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_tr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTr" ):
                return visitor.visitTr(self)
            else:
                return visitor.visitChildren(self)




    def tr(self):

        localctx = scslParser.TrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tr)
        try:
            self.state = 228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [38]:
                self.enterOuterAlt(localctx, 1)
                self.state = 222
                self.variable()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 223
                self.nextOp()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 224
                self.match(scslParser.LB)
                self.state = 225
                self.tr()
                self.state = 226
                self.match(scslParser.RB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(scslParser.VariableContext,0)


        def nextOp(self):
            return self.getTypedRuleContext(scslParser.NextOpContext,0)


        def beforeTr(self):
            return self.getTypedRuleContext(scslParser.BeforeTrContext,0)


        def tr(self):
            return self.getTypedRuleContext(scslParser.TrContext,0)


        def afterTr(self):
            return self.getTypedRuleContext(scslParser.AfterTrContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def c(self):
            return self.getTypedRuleContext(scslParser.CContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_c

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC" ):
                return visitor.visitC(self)
            else:
                return visitor.visitChildren(self)




    def c(self):

        localctx = scslParser.CContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_c)
        try:
            self.state = 242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [38]:
                self.enterOuterAlt(localctx, 1)
                self.state = 230
                self.variable()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 231
                self.nextOp()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 232
                self.beforeTr()
                self.state = 233
                self.tr()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 4)
                self.state = 235
                self.afterTr()
                self.state = 236
                self.tr()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 5)
                self.state = 238
                self.match(scslParser.LB)
                self.state = 239
                self.c()
                self.state = 240
                self.match(scslParser.RB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NextOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXTOPKWS(self):
            return self.getToken(scslParser.NEXTOPKWS, 0)

        def expr(self):
            return self.getTypedRuleContext(scslParser.ExprContext,0)


        def SATISFYING(self):
            return self.getToken(scslParser.SATISFYING, 0)

        def predicate(self):
            return self.getTypedRuleContext(scslParser.PredicateContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_nextOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNextOp" ):
                return visitor.visitNextOp(self)
            else:
                return visitor.visitChildren(self)




    def nextOp(self):

        localctx = scslParser.NextOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_nextOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(scslParser.NEXTOPKWS)
            self.state = 245
            self.expr()
            self.state = 246
            self.match(scslParser.SATISFYING)
            self.state = 247
            self.predicate()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CmpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return scslParser.RULE_cmp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCmp" ):
                return visitor.visitCmp(self)
            else:
                return visitor.visitChildren(self)




    def cmp(self):

        localctx = scslParser.CmpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_cmp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 14) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(scslParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(scslParser.MINUS, 0)

        def getRuleIndex(self):
            return scslParser.RULE_arithmetic

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmetic" ):
                return visitor.visitArithmetic(self)
            else:
                return visitor.visitChildren(self)




    def arithmetic(self):

        localctx = scslParser.ArithmeticContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_arithmetic)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            _la = self._input.LA(1)
            if not(_la==16 or _la==17):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Phi_singleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def phi_ts(self):
            return self.getTypedRuleContext(scslParser.Phi_tsContext,0)


        def phi_tr(self):
            return self.getTypedRuleContext(scslParser.Phi_trContext,0)


        def phi_c(self):
            return self.getTypedRuleContext(scslParser.Phi_cContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_phi_single

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhi_single" ):
                return visitor.visitPhi_single(self)
            else:
                return visitor.visitChildren(self)




    def phi_single(self):

        localctx = scslParser.Phi_singleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_phi_single)
        try:
            self.state = 256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 253
                self.phi_ts()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 254
                self.phi_tr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 255
                self.phi_c()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Phi_tsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v_ts(self):
            return self.getTypedRuleContext(scslParser.V_tsContext,0)


        def cmp(self):
            return self.getTypedRuleContext(scslParser.CmpContext,0)


        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_phi_ts

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhi_ts" ):
                return visitor.visitPhi_ts(self)
            else:
                return visitor.visitChildren(self)




    def phi_ts(self):

        localctx = scslParser.Phi_tsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_phi_ts)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.v_ts()
            self.state = 259
            self.cmp()
            self.state = 260
            self.real_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Phi_trContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v_tr(self):
            return self.getTypedRuleContext(scslParser.V_trContext,0)


        def cmp(self):
            return self.getTypedRuleContext(scslParser.CmpContext,0)


        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_phi_tr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhi_tr" ):
                return visitor.visitPhi_tr(self)
            else:
                return visitor.visitChildren(self)




    def phi_tr(self):

        localctx = scslParser.Phi_trContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_phi_tr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.v_tr()
            self.state = 263
            self.cmp()
            self.state = 264
            self.real_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Phi_cContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v_c(self):
            return self.getTypedRuleContext(scslParser.V_cContext,0)


        def cmp(self):
            return self.getTypedRuleContext(scslParser.CmpContext,0)


        def value(self):
            return self.getTypedRuleContext(scslParser.ValueContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_phi_c

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhi_c" ):
                return visitor.visitPhi_c(self)
            else:
                return visitor.visitChildren(self)




    def phi_c(self):

        localctx = scslParser.Phi_cContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_phi_c)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.v_c()
            self.state = 267
            self.cmp()
            self.state = 268
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Phi_multipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v_c(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(scslParser.V_cContext)
            else:
                return self.getTypedRuleContext(scslParser.V_cContext,i)


        def cmp(self):
            return self.getTypedRuleContext(scslParser.CmpContext,0)


        def v_ts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(scslParser.V_tsContext)
            else:
                return self.getTypedRuleContext(scslParser.V_tsContext,i)


        def timeBetween(self):
            return self.getTypedRuleContext(scslParser.TimeBetweenContext,0)


        def c(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(scslParser.CContext)
            else:
                return self.getTypedRuleContext(scslParser.CContext,i)


        def FROM(self):
            return self.getToken(scslParser.FROM, 0)

        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_phi_multiple

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhi_multiple" ):
                return visitor.visitPhi_multiple(self)
            else:
                return visitor.visitChildren(self)




    def phi_multiple(self):

        localctx = scslParser.Phi_multipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_phi_multiple)
        try:
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 270
                self.v_c()
                self.state = 271
                self.cmp()
                self.state = 272
                self.v_c()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.v_ts()
                self.state = 275
                self.cmp()
                self.state = 276
                self.v_ts()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 278
                self.timeBetween()
                self.state = 279
                self.c()
                self.state = 280
                self.match(scslParser.FROM)
                self.state = 281
                self.c()
                self.state = 282
                self.cmp()
                self.state = 283
                self.real_number()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeBetweenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIMEBETWEEN(self):
            return self.getToken(scslParser.TIMEBETWEEN, 0)

        def getRuleIndex(self):
            return scslParser.RULE_timeBetween

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeBetween" ):
                return visitor.visitTimeBetween(self)
            else:
                return visitor.visitChildren(self)




    def timeBetween(self):

        localctx = scslParser.TimeBetweenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_timeBetween)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(scslParser.TIMEBETWEEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class V_tsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNALVALUEKWS(self):
            return self.getToken(scslParser.SIGNALVALUEKWS, 0)

        def signal_variable(self):
            return self.getTypedRuleContext(scslParser.Signal_variableContext,0)


        def ATTIME(self):
            return self.getToken(scslParser.ATTIME, 0)

        def ts(self):
            return self.getTypedRuleContext(scslParser.TsContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def v_ts(self):
            return self.getTypedRuleContext(scslParser.V_tsContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def arithmetic(self):
            return self.getTypedRuleContext(scslParser.ArithmeticContext,0)


        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_v_ts

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitV_ts" ):
                return visitor.visitV_ts(self)
            else:
                return visitor.visitChildren(self)




    def v_ts(self):

        localctx = scslParser.V_tsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_v_ts)
        try:
            self.state = 304
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 289
                self.match(scslParser.SIGNALVALUEKWS)
                self.state = 290
                self.signal_variable()
                self.state = 291
                self.match(scslParser.ATTIME)
                self.state = 292
                self.ts(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 294
                self.match(scslParser.LB)
                self.state = 295
                self.v_ts()
                self.state = 296
                self.match(scslParser.RB)
                self.state = 297
                self.arithmetic()
                self.state = 298
                self.real_number()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 300
                self.match(scslParser.LB)
                self.state = 301
                self.v_ts()
                self.state = 302
                self.match(scslParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class V_trContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DURATION(self):
            return self.getToken(scslParser.DURATION, 0)

        def tr(self):
            return self.getTypedRuleContext(scslParser.TrContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def v_tr(self):
            return self.getTypedRuleContext(scslParser.V_trContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def getRuleIndex(self):
            return scslParser.RULE_v_tr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitV_tr" ):
                return visitor.visitV_tr(self)
            else:
                return visitor.visitChildren(self)




    def v_tr(self):

        localctx = scslParser.V_trContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_v_tr)
        try:
            self.state = 312
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.match(scslParser.DURATION)
                self.state = 307
                self.tr()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 308
                self.match(scslParser.LB)
                self.state = 309
                self.v_tr()
                self.state = 310
                self.match(scslParser.RB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class V_cContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUEKWS(self):
            return self.getToken(scslParser.VALUEKWS, 0)

        def string(self):
            return self.getTypedRuleContext(scslParser.StringContext,0)


        def IN(self):
            return self.getToken(scslParser.IN, 0)

        def c(self):
            return self.getTypedRuleContext(scslParser.CContext,0)


        def LB(self):
            return self.getToken(scslParser.LB, 0)

        def v_c(self):
            return self.getTypedRuleContext(scslParser.V_cContext,0)


        def RB(self):
            return self.getToken(scslParser.RB, 0)

        def arithmetic(self):
            return self.getTypedRuleContext(scslParser.ArithmeticContext,0)


        def real_number(self):
            return self.getTypedRuleContext(scslParser.Real_numberContext,0)


        def getRuleIndex(self):
            return scslParser.RULE_v_c

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitV_c" ):
                return visitor.visitV_c(self)
            else:
                return visitor.visitChildren(self)




    def v_c(self):

        localctx = scslParser.V_cContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_v_c)
        try:
            self.state = 329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 314
                self.match(scslParser.VALUEKWS)
                self.state = 315
                self.string()
                self.state = 316
                self.match(scslParser.IN)
                self.state = 317
                self.c()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 319
                self.match(scslParser.LB)
                self.state = 320
                self.v_c()
                self.state = 321
                self.match(scslParser.RB)
                self.state = 322
                self.arithmetic()
                self.state = 323
                self.real_number()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 325
                self.match(scslParser.LB)
                self.state = 326
                self.v_c()
                self.state = 327
                self.match(scslParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[15] = self.inner_sempred
        self._predicates[24] = self.ts_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def inner_sempred(self, localctx:InnerContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 7)
         

    def ts_sempred(self, localctx:TsContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         





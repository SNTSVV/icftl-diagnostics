"""
Module that provides the command line interface for inspection of monitoring/trace checking results.
"""

import argparse
import pathlib
import logging
import datetime
import os

from .data_formatter import Formatter
from .Database.database import Connection

# set database filename
DB_FILENAME = None

def check_database():
    """
    Given a database filename, check for 1) the file's existence, and 2) the existence of the tables
    in the database.
    """
    # check for file existence
    if not os.path.exists(DB_FILENAME):
        return False
    else:
        # check for existence of tables
        connection = Connection({"type": "sqlite", "filename": DB_FILENAME})
        tables_exist = connection.check_for_tables()
        if not tables_exist:
            return False

    # nothing went wrong, so return True
    return True

def main():
    global DB_FILENAME
    # define command line arguments
    parser = argparse.ArgumentParser(description="Inspect results of monitoring/trace checking for SCSL.")
    parser.add_argument("path_to_database",
                        help="URL of database containing results")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--delete-results",
                       action="store_true",
                       help="Delete all existing test results (from 'results.db').")
    group.add_argument("--all-tests",
                        action = 'store_true',
                        help="Get all tests found in the database.")
    group.add_argument("--all-test-suites",
                        action='store_true',
                        help="Get all tests found in the database.")
    group.add_argument("--all-specs",
                        action='store_true',
                        help="Get all specifications found in the database.")
    group.add_argument("--all-tests-violating-spec",
                        type=int,
                        help="Get all tests found in the database.")
    group.add_argument("--all-specs-violated-during-test",
                        type=str,
                        help="Get all specs that were violated while the given test was executing.")

    # parse the arguments
    args = parser.parse_args()

    # set database to use
    DB_FILENAME = args.path_to_database

    # initialise logging
    logging_path = pathlib.Path('./logs')
    logging_path.mkdir(exist_ok=True)
    logging.basicConfig(filename=f'{logging_path}/scsl-inspector-{datetime.datetime.now().isoformat()}',
                        filemode='a',
                        format='[%(asctime)s %(msecs)3d] [%(threadName)s] %(message)s',
                        datefmt='%H:%M:%S',
                        level=logging.INFO)

    # check for database existence, and existence of tables
    database_is_valid = check_database()
    if not database_is_valid:
        print("No database generated by a test suite run could be found.\n"
              "Try running your test suite first.")
        exit()

    # instantiate Formatter
    formatter = Formatter(DB_FILENAME)
    # decide which type of query to execute
    if args.all_tests:
        output = formatter.all_tests()
    elif args.all_test_suites:
        output = formatter.all_test_suites()
    elif args.all_specs:
        output = formatter.all_specs()
    elif args.all_tests_violating_spec is not None:
        output = formatter.all_tests_that_violated_spec(args.all_tests_violating_spec)
    elif args.all_specs_violated_during_test is not None:
        output = formatter.all_specs_violated_during_test(args.all_specs_violated_during_test)
    elif args.delete_results:
        # delete DB_FILENAME
        try:
            os.remove(DB_FILENAME)
            output = "Test results deleted."
        except:
            output = "Something went wrong when deleting the results data."



    print(output)
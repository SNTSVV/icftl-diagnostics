"""
Main module to handle logic for instrumentation.

Instrumentation consists of generating an instance of the Analyser class.

The purpose of the Analyser class is to perform the static analysis
necessary to determine from where in the monitored code base measurements should be taken
at runtime in order to check the iCFTL specification given.

The Analyser class take a VyPR.Specifications.builder.Specification instance
and a map from fully-qualified function names to the corresponding
VyPR.SCFG.builder.SCFG instances.

From here, the quantifiers are inspected (by traversal from the specification root
until the constraint) to determine the sequence of variables/predicates to use.

This process generates a set of maps from variables to symbolic states/pairs of symbolic states
in the set of SCFGs.

Based on these maps, the constraint part of the specification is then inspected
to determine the additional symbolic states/pairs of symbolic states that are needed.
"""

import logging

from ..Specifications.builder import (forall,
                                               exists,
                                               conjunction,
                                               disjunction,
                                               negate,
                                               is_normal_atom,
                                               is_mixed_atom,
                                               construct_cumulative_binding)
from ..Specifications.predicates import changes, calls, inTimeInterval
from ..Specifications.constraints import (TimeOfConcreteState,
                                                   TimeOfTransition,
                                                   TimestampVariable,
                                                   TimestampExpression,
                                                   BooleanConstant,
                                                   TimestampExpressionWithAddition,
                                                   derive_sequence_of_temporal_operators)
from .search import SCFGSearcher

class Analyser:
    """
    Class for static analysis of source code based on an iCFTL specification.
    """

    def __init__(self, specification, function_name_to_scfg_map):
        """
        Store the specification and function -> scfg map for use in other methods.
        """
        # store specification
        self._specification = specification
        logging.info(f"Specification is\n{self._specification}")

        # initialise the map from function names to SCFGs
        self._function_name_to_scfg_map = function_name_to_scfg_map
        
        # initialise SCFGSearcher instance using the function name -> SCFG map
        logging.info("Initialising a SCFGSearcher instance for the symbolic control-flow graphs")
        self._scfg_searcher = SCFGSearcher(function_name_to_scfg_map)
    
    def get_scfg_searcher(self):
        return self._scfg_searcher
    
    def compute_instrumentation_points(self):
        """
        Inspect the specification's quantifiers and constraint in order to compute
        the list of symbolic states/pairs of symbolic states at which instrumentation
        must be applied.

        Each instrumentation point should be a dictionary containing a type and various
        data useful for the instrumentation code that will be placed.

        Return the list of maps from variables to symbolic states (derived from quantifiers)
        and the tree of instrumentation points.
        """
        # compute the set of maps generated by quantifiers
        logging.info("Calling self._inspect_quantifiers to inspect quantifier sequence")
        variable_to_symbolic_state_maps, quantifier_expression_instrumentation_points = self._inspect_quantifiers()

        # check for no program points being captured
        if variable_to_symbolic_state_maps != {}:
            # based on these maps, compute a map (binding index, atom index, subatom index) -> list of symbolic states
            # of intrumentation points
            logging.info("Calling self._inspect_constraints() given statements identified by quantifiers")
            instrumentation_point_map = self._inspect_constraints(variable_to_symbolic_state_maps)
        else:
            instrumentation_point_map = {}

        return variable_to_symbolic_state_maps,\
               instrumentation_point_map,\
               quantifier_expression_instrumentation_points

    def _inspect_quantifiers(self) -> list:
        """
        Traverse the specification in order to determine maps from variables to symbolic states.
        """

        variables_to_sym_states, expression_maps = self.compute_bindings_from_quantifiers()

        return variables_to_sym_states, expression_maps
    
    def compute_bindings_from_quantifiers(self):
        """
        Recurse over the structure of the specification, deriving a set of maps from variables
        concrete states that satisfy the predicates in the quantifiers.
        Here, we omit timestamps (since these are not represented in the symbolic control-flow graphs,
        and we cannot currently instrument for them).
        """
        # initialise empty dictionary to map quantifier expressions to instrumentation points
        quantifier_expression_instrumentation_points = {}
        # initialise empty map from variables to lists of sym states
        variables_to_sym_states = {}
        # recurse on the structure of the specification
        self._compute_bindings_from_quantifiers(self._specification,
                                                variables_to_sym_states,
                                                quantifier_expression_instrumentation_points)
        return variables_to_sym_states, quantifier_expression_instrumentation_points

    def _compute_bindings_from_quantifiers(self,
                                           subformula,
                                           variables_to_sym_states,
                                           quantifier_expression_instrumentation_points,
                                           level=1):
        """
        Recursive case for extracting the set of bindings from SCFGs wrt a specification.
        """
        if is_normal_atom(subformula) or is_mixed_atom(subformula):
            # recursive base case
            pass
        else:
            if type(subformula) in [forall, exists]:
                # get the id of this quantifier
                quantifier_id = subformula.get_id()
                # get the predicate held by this quantifier
                predicate = subformula.get_predicate()
                
                # identify symbolic states based on predicates
                if type(predicate) in [changes, calls]:

                    # now, see if there's an "after" component of the predicate
                    if predicate.get_after_timestamp():
                        if type(predicate.get_after_timestamp()) is TimeOfConcreteState:
                            # compute the instrumentation points for the concrete state
                            # first, get the id of the base variable of the expression inside the timestamp operator
                            after_timestamp_quantifier_id = predicate.get_after_timestamp().get_base_variable().get_name()
                            # now, get the symbolic states required by that quantifier
                            sym_states = variables_to_sym_states[after_timestamp_quantifier_id]
                            # copy
                            sym_states_copy = [s for s in sym_states]
                            if subformula in quantifier_expression_instrumentation_points:
                                if 0 in quantifier_expression_instrumentation_points[subformula.get_id()]:
                                    quantifier_expression_instrumentation_points[subformula.get_id()][
                                        0] += sym_states_copy
                                else:
                                    quantifier_expression_instrumentation_points[subformula.get_id()][
                                        0] = sym_states_copy
                            else:
                                quantifier_expression_instrumentation_points[subformula.get_id()] = {
                                    0: sym_states_copy
                                }

                    # get the list of symbolic states that satisfy the predicate held by this quantifier
                    symbolic_states = self._scfg_searcher.find_symbolic_states(predicate)
                    # add each symbolic state to the map from variables to symbolic states, if not already found
                    for symbolic_state in symbolic_states:

                        # add sym state to map
                        if variables_to_sym_states.get(quantifier_id):
                            if symbolic_state not in variables_to_sym_states[quantifier_id]:
                                variables_to_sym_states[quantifier_id].append(symbolic_state)
                        else:
                            variables_to_sym_states[quantifier_id] = [symbolic_state]

                    # now, recurse on the subformula of the quantifier

                    # subformulas are implemented as lambdas, so we need to call those lambdas to have
                    # a subformula that can be recursed on
                    # instantiate the subformula of the quantifier (i.e., call the lambda)
                    # to call the lambda, we first need to decide which arguments to pass to it
                    argument_dict = construct_cumulative_binding(subformula)
                    # get the subformula
                    forall_subformula = subformula.get_subformula()
                    # instantiate the subformula
                    instantiated_subformula = forall_subformula(argument_dict)
                    # recurse with the extended binding
                    self._compute_bindings_from_quantifiers(instantiated_subformula,
                                                            variables_to_sym_states,
                                                            quantifier_expression_instrumentation_points,
                                                            level+1)

                elif type(predicate) is inTimeInterval:
                    # we have a quantifier over timestamps
                    # map the quantifier id to None, since we don't care about timestamps in instrumentation
                    variables_to_sym_states[quantifier_id] = []

                    # inspect the expressions used in the predicate to define an interval
                    # for example, if the predicate looks like [time(q), time(q) + 5],
                    # then we need to instrument for q to get the relevant timestamps at runtime
                    # for each expression that refers to source code in order to derive a timestamp,
                    # determine the relevant instrumentation points and store them
                    left_expression = predicate.get_left_expression()
                    right_expression = predicate.get_right_expression()
                    # determine the instrumentation points for each expression
                    if hasattr(left_expression, "is_signal_based") and not left_expression.is_signal_based():
                        # determine the instrumentation points based on the temporal operator held by left_expression
                        # this involves getting the symbolic state associated with that variable by the current binding,
                        # and then using the temporal operator component of left_expression to determine
                        # the symbolic states to instrument
                        temporal_operator_sequence = derive_sequence_of_temporal_operators(left_expression)[0]
                        symbolic_states = self._scfg_searcher.get_instrumentation_points_from_composition_sequence(
                            temporal_operator_sequence,
                            variables_to_sym_states
                        )
                        if subformula in quantifier_expression_instrumentation_points:
                            if 0 in quantifier_expression_instrumentation_points[subformula.get_id()]:
                                quantifier_expression_instrumentation_points[subformula.get_id()][0] += symbolic_states
                            else:
                                quantifier_expression_instrumentation_points[subformula.get_id()][0] = symbolic_states
                        else:
                            quantifier_expression_instrumentation_points[subformula.get_id()] = {
                                0 : symbolic_states
                            }

                    if hasattr(right_expression, "is_signal_based") and not right_expression.is_signal_based():
                        temporal_operator_sequence = derive_sequence_of_temporal_operators(right_expression)[0]
                        symbolic_states = self._scfg_searcher.get_instrumentation_points_from_composition_sequence(
                            temporal_operator_sequence,
                            variables_to_sym_states
                        )
                        if subformula in quantifier_expression_instrumentation_points:
                            if 1 in quantifier_expression_instrumentation_points[subformula.get_id()]:
                                quantifier_expression_instrumentation_points[subformula.get_id()][1] += symbolic_states
                            else:
                                quantifier_expression_instrumentation_points[subformula.get_id()][1] = symbolic_states
                        else:
                            quantifier_expression_instrumentation_points[subformula.get_id()].update({
                                1: symbolic_states
                            })
                
                    # instantiate the subformula of the quantifier
                    # construct argument dictionary
                    argument_dict = construct_cumulative_binding(subformula)
                    # get the subformula
                    forall_subformula = subformula.get_subformula()
                    # instantiate the subformula
                    instantiated_subformula = forall_subformula(argument_dict)
                    # recurse with the extended binding
                    self._compute_bindings_from_quantifiers(instantiated_subformula,
                                                            variables_to_sym_states,
                                                            quantifier_expression_instrumentation_points,
                                                            level + 1)
            
            elif type(subformula) is conjunction:
                # recurse on each subformula
                for conjunction_subformula in subformula.get_subformulae():
                    if type(conjunction_subformula) is not dict:
                        self._compute_bindings_from_quantifiers(conjunction_subformula,
                                                                variables_to_sym_states,
                                                                quantifier_expression_instrumentation_points,
                                                                level+1)

            elif type(subformula) is disjunction:
                # recurse on each subformula
                for disjunction_subformula in subformula.get_subformulae():
                    if type(disjunction_subformula) is not dict:
                        self._compute_bindings_from_quantifiers(disjunction_subformula,
                                                                variables_to_sym_states,
                                                                quantifier_expression_instrumentation_points,
                                                                level+1)

            elif type(subformula) is negate:
                # recurse on the subformula
                self._compute_bindings_from_quantifiers(subformula.get_subformula(),
                                                        variables_to_sym_states,
                                                        quantifier_expression_instrumentation_points,
                                                        level+1)

    def _inspect_constraints(self, variable_to_sym_states) -> dict:
        """
        For each variable in variable_to_sym_states, use the constraint part of the
        specification to determine the points from which data must be taken.

        To do this, iterate through the keys (variables) of variable_to_sym_states and, for each one,
        iterate through the atomic constraints and, for the ones that use the variable from variable_to_sym_states,
        use each one to find a list of symbolic states.

        The end result should be a map:

        (index of atomic constraint) -> (index of sub-atomic constraint) -> list of instrumentation points
        """
        logging.info("Beginning inspection of constraints")
        # initialise empty map for final lists of instrumentation points
        instrumentation_point_tree = {}
        # get the atoms in the specification
        atoms = self._specification.get_atoms()
        logging.info(f"atoms = {atoms}")
        # iterate through the atomic constraints
        for (atomic_constraint_index, atomic_constraint) in enumerate(atoms):
            # check for constant - we don't instrument for this
            if type(atomic_constraint) is not BooleanConstant:
                logging.info(f"Processing atomic_constraint_index = {atomic_constraint_index}")
                # add to instrumentation point tree
                instrumentation_point_tree[atomic_constraint_index] = \
                    self._scfg_searcher.get_instrumentation_points_for_atomic_constraint(
                        atomic_constraint,
                        variable_to_sym_states
                    )

        return instrumentation_point_tree
